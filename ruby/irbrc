# -*- mode: ruby -*-

IRB.conf[:IRB_NAME]="irb"
IRB.conf[:USE_READLINE] = false if ENV['EMACS']
IRB.conf[:BACK_TRACE_LIMIT] = 16
# IRB.conf[:AUTO_INDENT_MODE] = false
IRB.conf[:AUTO_INDENT] = true
IRB.conf[:USE_READLINE] = true
IRB.conf[:LOAD_MODULES] ||= []
IRB.conf[:LOAD_MODULES] |= ['irb/completion']
IRB.conf[:LOAD_MODULES] |= ['json']
IRB.conf[:LOAD_MODULES] |= ['yaml']
IRB.conf[:LOAD_MODULES] |= ['pp']

IRB.conf[:SAVE_HISTORY] = 10000
IRB.conf[:HISTORY_FILE] = "#{ENV['HOME']}/.irb_history"
IRB.conf[:EVAL_HISTORY] = 1000

IRB.conf[:PROMPT_MODE] = :DEFAULT
# IRB.conf[:PROMPT_MODE] = :SIMPLE
IRB.conf[:PROMPT][:MY] = {
  :PROMPT_I => "%N(%m):%03n:%i> ",   # simple prompt
  :PROMPT_N => "%N(%m):%03n:%i> ",   #
  :PROMPT_S => "%N(%m):%03n:%i%l ",  # prompt for continuated strings
  :PROMPT_C => "%N(%m):%03n:%i* ",   # prompt for continuated statement
  :RETURN => "=> %s\n"               # format to return value
}
IRB.conf[:PROMPT_MODE] = :MY
# IRB.conf[:PROMPT] = {...}

IRB.conf[:USE_AUTOCOMPLETE] = true

def history(count = 0)
  # Get history into an array
  histories = Readline::HISTORY.to_a

  count ||= 0
  if count > 0
    from = histories.length - count
    histories = histories[from..-1]
  end

  puts histories
end

def i_m(obj)
  list = obj.methods
  anc = obj.class.ancestors - [obj.class]
  anc.each {|a| list -= a.instance_methods }
  list.sort
end

def json_pp(json)
  require 'json'
  puts JSON.pretty_generate(JSON.parse(json))
end

## trace
# proc_object = proc do |event, file, line, id, binding, klass|
#   puts "#{event} in #{file}/#{line} #{id} #{klass}"
# end

# set_trace_func(proc_object)
