#+TITLE: 
#+AUTHOR: 
#+DATE: 
#+STARTUP: show3levels


* git
** basic
*** branch
**** delete
*** tag
*** log
**** nicely-formatted project-commit history
     #+begin_src shell
       git log --no-merges
     #+end_src
**** log filter
     #+begin_src shell
       git log --no-merges not-in-this-branch..but-in-this-branch
       
       git log --no-merges feature123..origin/master
     #+end_src

**** introduced by a branch
     commit in branch <branch>, but not present in master branch
     #+begin_src shell
       git log <branch> --not master
     #+end_src
*** diff
**** branch
     compare current branch with another branch
     #+begin_src shell
       git diff master
     #+end_src
**** introduced since its common ancestors
     introduced by <contrib> and not in master
     #+begin_src shell
       git diff master...<contrib>
     #+end_src
*** rebase
**** onto
     Take the client branch, figure out the patches since it diverged from the
     server branch, and replay these patches in the client branch as if it was
     based directly off the master branch instead.
     #+begin_src shell
       git rebase --onto master server client
     #+end_src
*** merge-base
**** common ancestor
     #+begin_src shell
       git merge-base <contrib> master
     #+end_src
*** publish over email
**** prepare patches
    generate patch
    #+begin_src shell
      git format-patch -M origin/master
    #+end_src
**** through gmail
    configure gmail in gitconfig
    #+begin_src ini
      [imap]
      folder = "[Gmail]/Drafts"
      host = imaps://imap.gmail.com
      user = user@gmail.com
      pass = YX]8g76G_2^sFbd
      port = 993
      sslverify = false
    #+end_src

    send by mail through git
    #+begin_src shell
      cat *.patch |git imap-send
    #+end_src

    then edit from draft in gmail
**** through smtp
     configure smtp in gitconfig
     #+begin_src ini
       [sendemail]
       smtpencryption = tls
       smtpserver = smtp.gmail.com
       smtpuser = user@gmail.com
       smtpserverport = 587
     #+end_src

     then send with
     #+begin_src shell
       git send-email *.patch
     #+end_src
**** apply patch
***** git apply
      #+begin_src shell
        git apply /tmp/patch-ruby-client.patch
      #+end_src

      - for a patch generated with git diff or diff
      - similar to running a patch -p1 command
      - behavior is: "apply all or abort all"

      check apply with:
      #+begin_src shell
        git apply --check 0001-see-if-this-helps-the-gem.patch
      #+end_src
***** git am
      #+begin_src shell
        git am 0001-limit-log-function.patch
      #+end_src

      - for a patch generated with git format-patch
      - for a patch sent with git send-email
      - "am" for "apply from a mailbox"
      - read/process a mbox file (plain-text)

      a 3-way merge:
      #+begin_src shell
        git am -3 0001-see-if-this-helps-the-gem.patch
      #+end_src

      a mbox file in interactive mode:
      #+begin_src shell
        git am -3 -i mbox
      #+end_src

      or from pull request url as a patch:
      #+begin_src shell
        curl https://github.com/tonychacon/fade/pull/1.patch | git am
      #+end_src
**** refrences
     - https://git-send-email.io
*** archive
    tar.gz format:
    #+begin_src shell
      git archive master --prefix='<project_name>/' | gzip > `git describe master`.tar.gz
    #+end_src

    zip format:
    #+begin_src shell
      git archive master --prefix='project/' --format=zip > `git describe master`.zip
    #+end_src
*** stash
**** basic
    - git stash (git stash push)
    - git stash list
    - git stash apply (git stash apply stash@{x})
    - git stash drop
    - git stash pop (apply + drop)
**** extra options
     - --keep-index
     - --include-untracked / -u
     - --all / -a
     - --patch  (interactive)
**** to branch
     #+begin_src emacs-lisp
       git stash branch <new branchname>
     #+end_src
*** clean
    no retrieving with clean action
    a safer option is to run git stash --all

    -n / --dry-run
    -f : force
    -d : remove files and empty directories
    -x : also consider files covered by .gitignore
    -i : interactive
** searching
*** grep
    #+begin_src shell
      git grep --help
    #+end_src

    example of complex search
    #+begin_src shell
      git grep --break --heading \
          -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
    #+end_src
*** log - pickaxe
    search for commit that changed the number of occurrences of that string
    #+begin_src shell
      git log -S ZLIB_BUF_MAX --oneline
    #+end_src
*** line log search
    search commit related to a specific function change

    every change made to the function git_deflate_bound in the zlib.c
    #+begin_src shell
      git log -L :git_deflate_bound:zlib.c
    #+end_src

    search in a block code defined by regexp
    #+begin_src shell
      git log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c
    #+end_src
** revision selection
*** SHA-1 hash
    40-character
    will move to SHA256
**** short SHA-1
    as long as:
    - at least four characters long
    - unambiguous
**** branch reference
    commit associated to branch:
    #+begin_src shell
      git rev-parse
    #+end_src
    will return the <commit-id>
*** reflog
    reflog information is strictly local !
    => a log only of what you’ve done in your repository
**** reflog shortnames
    reflog is a log of HEAD and branch references
    #+begin_src shell
      git reflog
    #+end_src

    can show the prior value of HEAD
    #+begin_src shell
      git reflog HEAD@{5}
    #+end_src

    can show the prior value of a <branch>
    #+begin_src shell
      git reflog <branch>@{6}
    #+end_src
**** reflog formatted like git log
    #+begin_src shell
      git log -g <branch>
    #+end_src
*** ancestry references
**** ~ (tilde)
     The “Specifying Revisions” section of the git rev-parse documentation
     defines ~ as:

     <rev>~<n>, e.g. master~3.
     A suffix ~<n> to a revision parameter means the commit object that is the
     nth generation ancestor of the named commit object, following only the
     first parents. For example, <rev>~3 is equivalent to <rev>^^^ which is
     equivalent to <rev>^1^1^1 …

     You can get to parents of any commit, not just HEAD. You can also move back
     through generations: for example, master~2 means the grandparent of the tip
     of the master branch, favoring the first parent on merge commits.

     Usage:
     - Use ~ most of the time — to go back a number of generations, usually what you want

     Mnemonics:
     - Tilde ~ is almost linear in appearance and wants to go backward in a straight line
**** ^ (caret)
     Git history is nonlinear: a directed acyclic graph (DAG) or tree. For a
     commit with only one parent, rev~ and rev^ mean the same thing. The caret
     selector becomes useful with merge commits because each one is the child of
     two or more parents — and strains language borrowed from biology.

     HEAD^ means the first immediate parent of the tip of the current branch.
     HEAD^ is short for HEAD^1, and you can also address HEAD^2 and so on as
     appropriate. The same section of the git rev-parse documentation defines it
     as:

     <rev>^, e.g. HEAD^, v1.5.1^0
     A suffix ^ to a revision parameter means the first parent of that commit
     object. ^<n> means the nth parent ([e.g.] <rev>^ is equivalent to <rev>^1).
     As a special rule, <rev>^0 means the commit itself and is used when <rev>
     is the object name of a tag object that refers to a commit object.

     Usage:
     - Use ^ on merge commits — because they have two or more (immediate) parents

     Mnemonics:
     - Caret ^ suggests an interesting segment of a tree or a fork in the road
**** ~  vs.  ^
     From: https://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git
***** rules of thumb
      Use ~ most of the time — to go back a number of generations, usually what you want
      Use ^ on merge commits — because they have two or more (immediate) parents
***** mnemonics
      Tilde ~ is almost linear in appearance and wants to go backward in a straight line
      Caret ^ suggests an interesting segment of a tree or a fork in the road
***** examples
      These specifiers or selectors can be chained arbitrarily, e.g., topic~3^2
      in English is the second parent of the merge commit that is the
      great-grandparent (three generations back) of the current tip of the
      branch topic.

      The aforementioned section of the git rev-parse documentation traces many
      paths through a notional git history. Time flows generally downward.
      Commits D, F, B, and A are merge commits.

      Here is an illustration, by Jon Loeliger. Both commit nodes B and C are
      parents of commit node A. Parent commits are ordered left-to-right. (N.B.
      The git log --graph command displays history in the opposite order.)

      G   H   I   J
       \ /     \ /
        D   E   F
         \  |  / \
          \ | /   |
           \|/    |
            B     C
             \   /
              \ /
               A

      A =      = A^0
      B = A^   = A^1     = A~1
      C = A^2
      D = A^^  = A^1^1   = A~2
      E = B^2  = A^^2
      F = B^3  = A^^3
      G = A^^^ = A^1^1^1 = A~3
      H = D^2  = B^^2    = A^^^2  = A~2^2
      I = F^   = B^3^    = A^^3^
      J = F^2  = B^3^2   = A^^3^2
*** commit ranges
**** double dot (..)
     asks to resolve a range of commits that are reachable from one commit
     but aren’t reachable from another

     #+begin_src shell
       git log master..experiment
       git log origin/master..HEAD
       git log origin/master..
     #+end_src

     git substitutes HEAD if one side is missing
**** multiple points
     equivalent:
     #+begin_src shell
       git log refA..refB
       git log ^refA refB
       git log refB --not refA
     #+end_src

     allow multiple references,
     see all commits that are reachable from refA or refB but not from refC:
     #+begin_src shell
       git log refA refB ^refC
       git log refA refB --not refC
     #+end_src
**** triple dot (...)
     asks to resolve all the commits that are reachable by either of two
     references but not by both of them

     a common switch to use with the log command in this case is --left-right,
     which shows you which side of the range each commit is in
     #+begin_src shell
       git log --left-right master...experiment
       < F
       < E
       > D
       > C
     #+end_src
** pull request
*** fetch manually
    use `git ls-remote` to list all remote references

    refs/pull/#/head: is the last commit in the branch/pr
    refs/pull/#/merge: is the resulting merge that would result

    then:
    #+begin_src shell
      git fetch origin refs/pull/958/head
    #+end_src
*** fetch server ref
    pull request ref are store in refs/pull

    add refspec to fetch server pull request reference
    #+begin_src conf
      [remote "origin"]
        url = https://github.com/libgit2/libgit2.git
        fetch = +refs/heads/*:refs/remotes/origin/*
        fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
    #+end_src
** rewriting history
*** amend
    #+begin_src shell
      git commit --amend
      git commit --amend --no-edit
    #+end_src
*** filter-branch
**** remove a file from entire history
     --tree-filter option runs the specified command after each checkout of the
     project and then recommits the results
     #+begin_src shell
       git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
     #+end_src
     or
     #+begin_src shell
       git filter-branch --tree-filter 'rm -f *~' HEAD
     #+end_src

     to run filter-branch on all your branches, you can pass --all to the
     command
**** making a subdirectory the new root
     project root is what was in the trunk subdirectory
     #+begin_src shell
       git filter-branch --subdirectory-filter trunk HEAD
     #+end_src
**** changing email addresses globally
     #+begin_src shell
       git filter-branch --commit-filter '
       if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
       then
         GIT_AUTHOR_NAME="Scott Chacon";
         GIT_AUTHOR_EMAIL="schacon@example.com";
         git commit-tree "$@";
       else
         git commit-tree "$@";
       fi' HEAD
     #+end_src
** advanced
*** plumbing
    #+begin_src shell
      git cat-file -p HEAD
      git ls-tree -r HEAD
      git ls-files -s
    #+end_src
*** reset
    does:
**** 1. move the branch that HEAD is pointing to (--soft)

        with HEAD pointing to master,
        git reset a1b2c3d4, make master point to a1b2c3d4

        with "reset --soft", it will stop there !!!

        revert git commit
**** 2. updating the index ([--mixed])
        update the index with the contents of whatever snapshot HEAD now points
        to

        with "reset --mixed", it will stop there !!!

        the default behavior

        revert git add
**** 3. updating the working directory (--hard)
        make the working directory look like the index
**** recap
     1. Move the branch HEAD points to (stop here if --soft).
     2. Make the index look like HEAD (stop here unless --hard).
     3. Make the working directory look like the index.
*** reset a path
**** unstage a file
    1. Move the branch HEAD points to (skipped).
    2. Make the index look like the HEAD (stop here).
    #+begin_src shell
      git reset file.txt
      git reset --mixed HEAD file.txt
    #+end_src
**** pull specific file version
     make the index look like the specific commit, for the file
     #+begin_src shell
      git reset eb43bf -- file.txt
     #+end_src
**** work by hunk
     accept a --patch option to unstage content on a hunk-by-hunk basis
     can selectively unstage or revert content
**** squashing
     squashing the 2 last commit with:
     #+begin_src shell
       git reset --soft HEAD~2
       git commit
     #+end_src
*** checkout
**** without path
     #+begin_src shell
       git checkout [branch]
     #+end_src
     is similar to
     #+begin_src shell
       git reset --hard [branch]
     #+end_src

     with 2 major differences:
     - checkout is working-directory safe (no destroy)
     - checkout updates HEAD
     while:
     - reset will simply replace everything without checking
     - reset will move the branch that HEAD points to
**** with path
    #+begin_src shell
      git checkout -- file
    #+end_src
    like
    #+begin_src shell
      git reset --hard [branch] file
    #+end_src

    - it’s not working-directory safe
    - it does not move HEAD

    accept a --patch option to allow you to selectively revert file contents on
    a hunk-by-hunk basis
*** reset vs. checkout summary
    |                           | HEAD | Index | Workdir | WD Safe ? |
    |---------------------------+------+-------+---------+-----------|
    | Commit Level              |      |       |         |           |
    | reset --soft [commit]     | REF  | NO    | NO      | YES       |
    | reset [--mixed] [commit]  | REF  | YES   | NO      | YES       |
    | reset --hard [commit]     | REF  | YES   | YES     | NO        |
    | checkout <commit>         | HEAD | YES   | YES     | YES       |
    |---------------------------+------+-------+---------+-----------|
    | File Level                |      |       |         |           |
    | reset [commit] <paths>    | NO   | YES   | NO      | YES       |
    | checkout [commit] <paths> | NO   | YES   | YES     | NO        |
    |---------------------------+------+-------+---------+-----------|
*** merging
**** ignoring whitesapce
     a lifesaver if you have someone on your team who likes to occasionally
     reformat everything from spaces to tabs or vice-versa

     add -Xignore-all-space or -Xignore-space-change

     #+begin_src shell
       git merge -Xignore-space-change whitespace
     #+end_src
**** in a merge conflict
     browse the 3 file versions
     - stage 1 is the common ancestor
     - stage 2 is your version ("ours")
     - stage 3 is from the MERGE_HEAD, the version you’re merging in ("theirs")

     #+begin_src shell
       git show :1:hello.rb > hello.common.rb
       git show :2:hello.rb > hello.ours.rb
       git show :3:hello.rb > hello.theirs.rb
     #+end_src

     #+begin_src shell
       git ls-files -u
       100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1 hello.rb
       100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2 hello.rb
       100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3 hello.rb
     #+end_src

     #+begin_src shell
       git merge-file -p \
           hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb
     #+end_src

     before commit, can check diff status,

     to see what the merge introduced:
     #+begin_src shell
       git diff --ours
     #+end_src

     to see how the result of the merge differed from what was on their side
     #+begin_src shell
       git diff --theirs
     #+end_src

     to see how the file has changed from both sides
     #+begin_src shell
       git diff --base
     #+end_src

     then before commit, clean
     #+begin_src shell
       git clean -f
     #+end_src
**** checkout conflict
     checkout conflict context
     #+begin_src shell
       git checkout --conflict=diff3 hello.rb
     #+end_src

     checkout "ours" version
     #+begin_src shell
       git checkout --ours hello.rb
     #+end_src

     checkout "theirs" version
     #+begin_src shell
       git checkout --theirs hello.rb
     #+end_src
**** log to get merge context
     to get a full list of all of the unique commits that were included in
     either branch involved in this merge, we can use the "..." syntax
     #+begin_src shell
       git log --oneline --left-right HEAD...MERGE_HEAD
     #+end_src

     we add the --merge option to git log, it will only show the commits in
     either side of the merge that touch a file that’s currently conflicted
     #+begin_src shell
       git log --oneline --left-right --merge [-p]
     #+end_src
     with the -p option, you get just the diffs to the file that ended up in
     conflict
**** combined diff
     before the resolution :
     - the first column shows you if that line is different (added or removed)
       between the “ours” branch and the file in your working directory
     - the second column does the same between the “theirs” branch and your
       working directory copy
     #+begin_src shell
       git diff
     #+end_src

     after the resolution:
     #+begin_src shell
       git log --cc -p -1
     #+end_src
*** undoing merges
**** git reset
     #+begin_src shell
       git reset --hard HEAD~
     #+end_src

     to avoid if :
     - published
     - any other commits have been created since the merge
**** reverse
     #+begin_src shell
       git revert -m 1 HEAD
     #+end_src

     if trying to remerge:
     - git will get confused if you try to merge topic into master again
       there’s nothing in topic that isn’t already reachable from master
     - if you add work to topic and merge again, Git will only bring in the
       changes since the reverted merge
     finaly the best way around this is to un-revert the original merge
     #+begin_src shell
       git revert ^M
       git merge topic  # to have additionnal work
     #+end_src
*** merge
**** preferences
     prefer git to simply choose a specific side and ignore the other side
     instead of letting you manually resolve the conflict:
     - -Xours
     - -Xtheirs

     prefer "ours" in case of conflict:
     #+begin_src shell
       git merge -Xours feature-branch
     #+end_src
**** strategy
     specify a strategy:
     - -s ours
     - -s theirs

     This will basically do a fake merge. It will record a new merge commit with
     both branches as parents, but it will not even look at the branch you’re
     merging in. It will simply record as the result of the merge the exact code
     in your current branch.
     #+begin_src shell
       git merge -s ours feature-branch
     #+end_src
*** rerere
**** usage
     - with rerere enabled, you can attempt the occasional merge, resolve the
       conflicts, then back out of the merge
     - if you want to keep a branch rebased so you don’t have to deal with the
       same rebasing conflicts each time you do it
**** enable
     #+begin_src shell
       git config --global rerere.enabled true
     #+end_src

     or by creating: .git/rr-cache
**** flow
     to show pre-merge state:
     #+begin_src shell
       git rerere status
     #+end_src

     to show the current state of the resolution:
     (what you started with to resolve and what you’ve resolved it to)
     #+begin_src shell
       git rerere diff
     #+end_src

     try to run pre-recorded:
     #+begin_src shell
       git rerere
     #+end_src
** Sign
*** sign with gpg
    use gpg format
    #+begin_src shell
      git config --global --unset gpg.format
    #+end_src

    use an existing private key
    (private key is required for signing commits or tags)
    #+begin_src shell
      gpg --list-secret-keys --keyid-format=long
    #+end_src

    or create a new sign key
    #+begin_src shell
      gpg --gen-key
    #+end_src

    configure git to use this key
    (when setting a subkey include the ! suffix)
    #+begin_src shell
      git config --global user.signingkey <0A12345!>
    #+end_src

    tell git to sign all commits by default
    #+begin_src shell
      git config --global commit.gpgsign true
    #+end_src
*** sign with ssh key
    use ssh format
    #+begin_src shell
      git config --global gpg.format ssh
    #+end_src

    set your SSH signing key
    #+begin_src shell
      git config --global user.signingkey /PATH/TO/.SSH/KEY.PUB
    #+end_src
*** sign with X.509
    install smimesign
    from https://github.com/github/smimesign

    To use S/MIME to sign for all repositories
    #+begin_src shell
      git config --global gpg.x509.program smimesign
      git config --global gpg.format x509
    #+end_src

    To use S/MIME to sign for a single repository
    #+begin_src shell
      cd PATH-TO-REPOSITORY
      git config --local gpg.x509.program smimesign
      git config --local gpg.format x509
    #+end_src

    If you're not using an X.509 key that matches your committer identity, list
    X.509 keys for which you have both a certificate and private key
    #+begin_src shell
      smimesign --list-keys
    #+end_src

    From the list of X.509 keys, copy the certificate ID of the X.509 key you'd
    like to use

    To use your X.509 key to sign for all repositories
    #+begin_src shell
      git config --global user.signingkey 0ff455a2708394633e4bb2f88002e3cd80cbd76f
    #+end_src

    To use your X.509 key to sign for a single repository
    #+begin_src shell
      cd  PATH-TO-REPOSITORY
      git config --local user.signingkey 0ff455a2708394633e4bb2f88002e3cd80cbd76f
    #+end_src
*** configuration references
    https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key
*** tags
    signed tag: -s instead of -a
    #+begin_src shell
      git tag -s v1.5 -m 'my signed 1.5 tag'
    #+end_src

    verify with
    #+begin_src shell
      git tag -v v1.5
    #+end_src
*** commit
    sign with -S
    #+begin_src shell
      git commit -a -S -m 'Signed commit'
    #+end_src

    browse commit with signature
    #+begin_src shell
      git log --show-signature -1
    #+end_src

    show commit with signature
    #+begin_src shell
      git show --show-signature 5c3386cf
    #+end_src

    merge and pull verifying
    #+begin_src shell
      git merge --verify-signatures <branch>
    #+end_src

    merge verifying and sign
    #+begin_src shell
      git merge --verify-signatures -S <branch>
    #+end_src
*** share pub key
    list keys:
    #+begin_src shell
      gpg --list-keys
    #+end_src

    export pub to git blob:
    #+begin_src shell
      gpg -a --export F721C45A | git hash-object -w --stdin
    #+end_src

    add annoted tag, to identify it:
    #+begin_src shell
      git tag -a gpg-pub-maintainer <git blob sha id>
    #+end_src

    import pub key from git to gpg
    #+begin_src shell
      git show gpg-pub-maintainer | gpg --import
    #+end_src
** submodules
*** basic
    init with
    #+begin_src shell
      git submodule add https://github.com/.../project_a
    #+end_src

    check status from root repository:
    #+begin_src shell
      git diff --cached project_a
      git diff --cached --submodule
    #+end_src

    then commit
*** config
**** diff display submodule info by default
     #+begin_src shell
       git config --global diff.submodule log
     #+end_src
**** submodule remote branch
     change in .gitmodules (global)
     #+begin_src shell
       git config -f .gitmodules submodule.<submodule>.branch <branch>
     #+end_src

     or in .git/config (local)
     #+begin_src shell
       git config submodule.<submodule>.branch <branch>
     #+end_src
**** submodule summary in git status
     #+begin_src shell
       git config status.submodulesummary 1
     #+end_src
**** always pull with --recurse-submodules
     #+begin_src shell
       git config submodule.recurse true
     #+end_src
     will make Git use the --recurse-submodules flag for all commands that
     support it (except clone)
**** push with submodule check
     #+begin_src shell
       git config push.recurseSubmodules check
     #+end_src
     check option will make push simply fail if any of the committed submodule
     changes haven’t been pushed

     can be changed to on-demand to push submodules automatically
*** cloning project with submodules
    simple cloning does not checkout submodules

    to have submodules:
    - init local config files
    - fetch and checkout submodules to the appropriate commit
    #+begin_src shell
      git submodule init
      git submodule update
    #+end_src
    or
    #+begin_src shell
      git submodule update --init
    #+end_src

    to allow recursive submodules:
    #+begin_src shell
      git submodule update --init --recursive
    #+end_src

    or clone with:
    #+begin_src shell
        git clone --recurse-submodules https://github.com/.../project_a
    #+end_src
*** working on project with submodules
**** status
     #+begin_src shell
       git diff --submodule
     #+end_src
**** pulling update on submodule
     do it manually by sumodule,
     or let git do it
     #+begin_src shell
       git submodule update --remote [submodule]
     #+end_src
**** pulling project with submodule
     git pull will not update submodule by default,
     also use:
     #+begin_src shell
       git submodule update --init --recursive
     #+end_src

     or use:
     #+begin_src shell
       git pull --recurse-submodules
     #+end_src
**** changes in submodule reference
     after a change in submodule reference (.gitmodules)
     if git pull --recurse-submodules, or git submodule update, fail
     #+begin_src shell
       # copy the new URL to your local config
       git submodule sync --recursive
       # update the submodule from the new URL
       git submodule update --init --recursive
     #+end_src
**** working in submodule
     change submodule branch
     #+begin_src shell
       cd <submodule>
       git checkout stable
     #+end_src

     merge a change from remote
     #+begin_src shell
       git submodule update --remote --merge
     #+end_src

     rebase on remote updates
     #+begin_src shell
       git submodule update --remote --rebase
     #+end_src

     without --rebase or --merge, Git will just update the submodule to whatever
     is on the server and reset your project to a detached HEAD state
     #+begin_src shell
       checkout git submodule update --remote
     #+end_src
**** publishing submodule changes
     push root repository, without pushing submodules can lead to trouble, since
     theere will be no way to get the submodule changes that are depended on

     push from root in check mode:
     #+begin_src shell
       git push --recurse-submodules=check
     #+end_src

     or push in on-demand mode, so git will try to do this for you
     #+begin_src shell
       git push --recurse-submodules=on-demand
     #+end_src
**** merging submodule changes
     use git diff to understand the conflict
     #+begin_src shell
       git diff
       diff --cc DbConnector
       index eb41d76,c771610..0000000
       --- a/DbConnector
       +++ b/DbConnector
     #+end_src
     conflict between commit id eb41d76 and c771610

     solve it:
     #+begin_src shell
       cd <submodule>

       git rev-parse HEAD
       eb41d764bccf88be77aced643c13a7fa86714135

       git branch try-merge c771610

       git merge try-merge

       cd ..

       git diff

       git add <submodule>

       git commit ...
     #+end_src
*** tips
**** submodule foreach
     run a command in all submodules
     #+begin_src shell
       git submodule foreach 'git stash'

       git submodule foreach 'git checkout -b featureA'
     #+end_src

     for example, generate a unified diff
     #+begin_src shell
       git diff; git submodule foreach 'git diff'
     #+end_src

** commands
*** add
**** --patch / -p
     answers:
     y : yes
     n : no
     q : quit
     a
     d : discard
     /
     s : split
     e : edit
     ? : help
     j/k : jump previous/next hunk
*** bisect
    does a binary search through your commit history to help you identify as
    quickly as possible which commit introduced an issue

**** manual flow
     1. start
     2. tell the current commit is broken / bad
     3. tell the last good known state
     #+begin_src shell
       git bisect start
       git bisect bad
       git bisect good v1.0
     #+end_src

     4. run the binary search
        either state is good
        either state is bad
     #+begin_src shell
       git bisect good
       git bisect bad
     #+end_src

     5. until the last remaining commit

     6. reset HEAD to where it was before start
     #+begin_src shell
       git bisect reset
     #+end_src
**** auto flow
     if you have a script that will exit 0 if the project is good or non-0 if
     the project is bad, you can fully automate git bisect

     1. start by providing the known bad and good commits
     2. run the test script
     #+begin_src shell
       git bisect start HEAD v1.0
       git bisect run test-error.sh
     #+end_src
*** blame
    determine modification in the feature branch
    #+begin_src shell
      git blame master..feature
    #+end_src

    determine which commit and committer was responsible for lines 69 to 82
    #+begin_src shell
      git blame -L 69,82 Makefile
    #+end_src

    determine reponsible for a function
    #+begin_src shell
      git blame -L :function code.rb
    #+end_src

    can detect code move, copy, ...
    with -C option
*** bundle
**** create
     #+begin_src shell
       git bundle create repo.bundle HEAD master
     #+end_src

     add HEAD as a reference of the default branch to checkout
**** clone
     #+begin_src shell
       git clone repo.bundle repo
     #+end_src
**** commit range
     determine the commit range with git log
     #+begin_src shell
       git log --oneline master ^origin/master
       git log --oneline origin/master..master
     #+end_src

     use the range to create bundle
     #+begin_src shell
       git bundle create commits.bundle master ^9a466c5
     #+end_src
**** verify status
     #+begin_src shell
       git bundle verify ../commits.bundle
     #+end_src

     inform if it can be integrated in the current repo
**** import content
     list referenreces
     #+begin_src shell
       git bundle list-heads ../commits.bundle
     #+end_src

     fetch reference
     #+begin_src shell
       git fetch ../commits.bundle master:other-master
     #+end_src
*** config
**** help
     - man git-config
     - https://git-scm.com/docs/git-config
*** diff
**** compare individual file between commits
     #+begin_src shell
       git diff head~3:README.md..head:README.md
     #+end_src
**** check for whitespace
     #+begin_src shell
       git diff --check
     #+end_src

     in relation with core.whitespace config
     - blank-at-eol : blank at end of line
     - blank-at-eof : blank at end of file
     - space-before-tab
     - cr-at-eol
     - tab-in-indent : tab used for indent instead of tab
     - indent-with-non-tab : space used for indent instead of tab
     - trailing-space = blank-at-eol + blank-at-eof
*** diff-tree
    to compare what is in your subdirectory with what the branch on the remote
    server was the last time you fetched, you can run:
    #+begin_src shell
      git diff-tree -p branch
      git diff-tree -p remote/branch
    #+end_src
*** log
**** ancestry-path: range of commit between 2 references
     list range of commit between 2 references,
     like in git diff
     #+begin_src shell
       git log --ancestry-path feature..master
     #+end_src
     give commit list, from master to reach the feature ancestor
*** ls-files
    list conflicted files:
    #+begin_src shell
      git ls-files -u
    #+end_src
*** rebase
**** rebase feature branch on top of master
     from any branch:
     #+begin_src shell
       git rebase master feature
     #+end_src

     and from feature branch:
     #+begin_src shell
       git rebase master
     #+end_src
**** hands-on
     https://git-rebase.io/
*** replace
    to pretend to replace objects in the git database with other objects
*** shortlog
    compute statistic per Author

    -s : sum the number of commit per Author
    -n : sort the result by number of commit
*** show
    - --no-patch : remove patch section
    - --stat : include summary of the change
*** show-branch
    limit view, focus on specific branch

    * : mark current branch
    + : regular commit
    - : merge commit

    at the end of the list, the first common ancestor
**** topic
     #+begin_src shell
       git show-branch --topic master feature experiment
     #+end_src
     show graphically branches
       filtering commit already merged in the topic branch
       showing only commit not merged into the topic branch
** Server
*** shared repository
    #+begin_src shell
      cd <repository_dir>
      git init --bare --shared
    #+end_src
*** ssh
*** http
**** dumb protocol
     setup git server through http dumb protocol with:
     #+begin_src shell
       cd /var/www/htdocs/
       git clone --bare /path/to/git_project gitproject.git
       cd gitproject.git
       mv hooks/post-update.sample hooks/post-update
       chmod a+x hooks/post-update
     #+end_src
**** smart http
***** prepare apache
      #+begin_src shell
        sudo apt-get install apache2 apache2-utils
        a2enmod cgi alias env

        chgrp -R www-data /srv/git
      #+end_src
***** apache configuration
      #+begin_src conf
        SetEnv GIT_PROJECT_ROOT /srv/git
        SetEnv GIT_HTTP_EXPORT_ALL
        ScriptAlias /git/ /usr/lib/git-core/git-http-backend/
      #+end_src

      #+begin_src conf
        <Files "git-http-backend">
          AuthType Basic
          AuthName "Git Access"
          AuthUserFile /srv/git/.htpasswd
          Require expr !(%{QUERY_STRING} -strmatch '*service=git-receive-pack*' ||
          %{REQUEST_URI} =~ m#/git-receive-pack$#)
          Require valid-user
        </Files>
      #+end_src

      #+begin_src shell
        htpasswd -c /srv/git/.htpasswd schacon
      #+end_src
*** git daemon
**** command
     #+begin_src shell
       git daemon --reuseaddr --base-path=<directory> <directory>
     #+end_src
**** systemctl
     #+begin_src ini
       [Unit]
       Description=Start Git Daemon

       [Service]
       ExecStart=/usr/bin/git daemon --reuseaddr --base-path=/srv/git/ /srv/git/
       Restart=always
       RestartSec=500ms
       StandardOutput=syslog
       StandardError=syslog
       SyslogIdentifier=git-daemon
       User=git
       Group=git

       [Install]
       WantedBy=multi-user.target
     #+end_src
**** allow access
     #+begin_src shell
       cd /path/to/project.git
       touch git-daemon-export-ok
     #+end_src
*** gitweb
**** start with webrick
     #+begin_src shell
       git instaweb --httpd=webrick
     #+end_src
**** stop
     #+begin_src shell
       git instaweb --httpd=webrick --stop
     #+end_src
**** build gitweb
     #+begin_src shell
       git clone git://git.kernel.org/pub/scm/git/git.git
       cd git/
       make GITWEB_PROJECTROOT="/srv/git" prefix=/usr gitweb
         SUBDIR gitweb
         SUBDIR ../
       make[2]: `GIT-VERSION-FILE' is up to date.
         GEN gitweb.cgi
         GEN static/gitweb.js
       sudo cp -Rf gitweb /var/www/
     #+end_src
**** with Apache and SCGI
     #+begin_src conf
       <VirtualHost *:80>
         ServerName gitserver
         DocumentRoot /var/www/gitweb
         <Directory /var/www/gitweb>
           Options +ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
           AllowOverride All
           order allow,deny
           Allow from all
           AddHandler cgi-script cgi
           DirectoryIndex gitweb.cgi
         </Directory>
       </VirtualHost>
     #+end_src
*** gitlab
*** public git hosting sites
    https://git.wiki.kernel.org/index.php/GitHosting
*** config
**** receive.fsckObjects
     Git is capable of making sure every object received during a push still
     matches its SHA-1 checksum and points to valid objects. However, it doesn’t
     do this by default; it’s a fairly expensive operation, and might slow down
     the operation, especially on large repositories or pushes.
     #+begin_src shell
       git config --system receive.fsckObjects true
     #+end_src
**** receive.denyNonFastForwards
     To tell Git to refuse force-pushes.
     #+begin_src shell
       git config --system receive.denyNonFastForwards true
     #+end_src
     The other way you can do this is via server-side receive hooks.
**** receive.denyDeletes
     One of the workarounds to the denyNonFastForwards policy is for the user to
     delete the branch and then push it back up with the new reference. To avoid
     this, set receive.denyDeletes to true.
     #+begin_src shell
       git config --system receive.denyDeletes true
     #+end_src
** credentials
*** storage
    to configure with
    #+begin_src shell
      git config --global credential.helper cache
    #+end_src

    storage type are:
    - (default) no cache at all
    - "cache" mode keeps credentials in memory for a certain period of time (15 minutes)
    - "store" mode aves the credentials to a plain-text file on disk, and they never expire

    a helper called "Git Credential Manager", this uses platform-native data
    stores to control sensitive information
    (https://github.com/GitCredentialManager/git-credential-manager)

    example:
    #+begin_src shell
      git config --global credential.helper 'store --file ~/.my-credentials'
    #+end_src
    or
    #+begin_src shell
      git config --global credential.helper 'cache --timeout 900'
    #+end_src
*** protocol
    #+begin_src shell
      git credential fill
      protocol=https
      host=mygithost

      protocol=https
      host=mygithost
      username=bob
      password=s3cre7

      git credential fill
      protocol=https
      host=unknownhost
      Username for 'https://unknownhost': bob
      Password for 'https://bob@unknownhost':
      protocol=https
      host=unknownhost
      username=bob
      password=s3cre7
    #+end_src

    The credential system is actually invoking a program that’s separate from
    Git itself; which one and how depends on the credential.helper configuration
    value.

    | Configuration Value                 | Behavior                             |
    |-------------------------------------+--------------------------------------|
    | foo                                 | Runs git-credential-foo              |
    | foo -a --opt=bcd                    | Runs git-credential-foo -a --opt=bcd |
    | /absolute/path/foo -xyz             | Runs /absolute/path/foo -xyz         |
    | !f() { echo "password=s3cre7"; }; f | Code after ! evaluated in shell      |

    the general form for this is "git-credential-foo [args] <action>"

    the stdin/stdout protocol is the same as git-credential, but they use a
    slightly different set of actions:
    - get is a request for a username/password pair.
    - store is a request to save a set of credentials in this helper’s memory.
    - erase purge the credentials for the given properties from this helper’s memory.

    #+begin_src shell
      git credential-store --file ~/git.store store
      protocol=https
      host=mygithost
      username=bob
      password=s3cre7

      git credential-store --file ~/git.store get
      protocol=https
      host=mygithost
      username=bob
      password=s3cre7
    #+end_src
*** custom
    action to implement:
    - get
    - store
    - erase

    create git-credential-read-only :
    #+begin_src ruby
      #!/usr/bin/env ruby

      require 'optparse'

      path = File.expand_path '~/.git-credentials'
      OptionParser.new do |opts|
        opts.banner = 'USAGE: git-credential-read-only [options] <action>'
        opts.on('-f', '--file PATH', 'Specify path for backing store') do |argpath|
          path = File.expand_path argpath
        end
      end.parse!

      exit(0) unless ARGV[0].downcase == 'get'
      exit(0) unless File.exists? path

      known = {}
      while line = STDIN.gets
        break if line.strip == ''
        k,v = line.strip.split '=', 2
        known[k] = v
      end

      File.readlines(path).each do |fileline| ④
        prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first
        if prot == known['protocol'] and host == known['host'] and user == known['username'] then
          puts "protocol=#{prot}"
          puts "host=#{host}"
          puts "username=#{user}"
          puts "password=#{pass}"
          exit(0)
        end
      end
    #+end_src
    put it somewhere in our PATH and mark it executable

    test it:
    #+begin_src shell
      git credential-read-only --file=/mnt/shared/creds get
      protocol=https
      host=mygithost
      username=bob

      protocol=https
      host=mygithost
      username=bob
      password=s3cre7
    #+end_src

    configure helper:
    #+begin_src shell
      git config --global credential.helper 'read-only --file /mnt/shared/creds'
    #+end_src
** gitattributes
*** location
    - .gitattributes
    - .git/info/attributes
*** binary file
    inform git that *.pbxproj are binary
    #+begin_src conf
      *.pbxproj binary
    #+end_src
*** diff docx file
    ask git to use word diff filter when trying to view change
    #+begin_src conf
      ,*.docx diff=word
    #+end_src

    then create the filter script
    #+begin_src shell
      #!/bin/bash
      docx2txt.pl "$1" -
    #+end_src

    then configure git word filter
    #+begin_src shell
      git config diff.word.textconv docx2txt
    #+end_src

    git diff will now try to display a diff status
*** diff of png file
    define gitattributes
    #+begin_src conf
      ,*.png diff=exif
    #+end_src

    configure git exif filter
    #+begin_src shell
      git config diff.exif.textconv exiftool
    #+end_src

    now git diff display exif changes
*** smudge and clean
    - smudge filter is run on checkout (to workdir)
    - clean filter is run when files are staged (to index)

    the .gitattributes file is committed and passed around with the project
    but the filter isn't, so it won't work everywhere
**** example on C source
     define filter indent on *.c source code
     #+begin_src conf
       ,*.c filter=indent
     #+end_src

     define git filter
     #+begin_src shell
       git config --global filter.indent.clean indent
       git config --global filter.indent.smudge cat
     #+end_src
**** expand last commit date
     will replace $Date$ placeholder with last commit date

     create expand_date script
     #+begin_src ruby
       #! /usr/bin/env ruby
       data = STDIN.read
       last_date = `git log --pretty=format:"%ad" -1`
       puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')
     #+end_src

     define git filter
     #+begin_src shell
       git config filter.dater.smudge expand_date
       git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'
     #+end_src

     define git attribute
     #+begin_src conf
       date*.txt filter=dater
     #+end_src
*** export-ignore for archive
    tell Git not to export certain files or directories when generating an archive

    to exclude test/ directory, add in .gitattributes
    #+begin_src conf
      test/ export-ignore
    #+end_src

    now, when running git archive, test will not be included in the archive
*** export-subst for archive
    to apply git log’s formatting and keyword-expansion processing to selected
    portions of files marked with the export-subst attribute

    to have metadata about the last commit automatically injected into it when
    git archive runs

    define .gitattributes
    #+begin_src conf
      LAST_COMMIT export-subst
    #+end_src

    init LAST_COMMIT content (following log format)
    #+begin_src shell
      echo 'Last commit date: $Format:%cd by %aN$' > LAST_COMMIT
    #+end_src
    then add and commit.

    now, when running git archive, LAST_COMMIT will look like
    #+begin_src text
      Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon
    #+end_src

    with a more complex example:
    #+begin_src shell
      echo '$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$' > LAST_COMMIT
    #+end_src
*** merge strategies
    define merge strategies in gitattributes
    to protect a file content

    define git attribute:
    #+begin_src conf
      database.xml merge=ours
    #+end_src

    define the dummy ours merge strategy
    #+begin_src shell
      git config --global merge.ours.driver true
    #+end_src
** hooks
*** location
    the hooks are all stored in the hooks subdirectory of the Git directory
    - .git/hooks

    generally populated at init time with sample

    a valid hooks should be:
    - in .git/hooks directory
    - named correctly
    - executable
*** client-side
    triggered by operations such as committing and merging

    client-side hooks are not copied when you clone a repository !
**** committing-workflow hooks
***** pre-commit
      - run first
      - before you even type in a commit message
      - used to inspect the snapshot to be committed
      - for example, check linter
      - for example, to make sure tests run
      - for example, to inspect the code
      - for example, check for trailing whitespace (default example)
      - exiting non-zero from this hook aborts the commit
      - can be bypassed with "git commit --no-verify"
***** prepare-commit-msg
      - after the default commit message is created
      - run before the commit message editor is fired up
      - lets you edit the default message before the commit author
      - takes parameters
        - path to the file that holds the commit message
        - type of commit
        - commit SHA-1 (if is an amended commit)
      - for example, to auto-generate message content
      - for example, to programmatically insert information
***** commit-msg
      - takes parameters
        - the path to a temporary file that contains the commit message written by the developer
      - on non-zero exit, aborts the commit process
      - for example, to validate your project state
      - for example, to validate commit message
***** post-commit
      - takes 0 parameter
      - can't stop the patching process
      - for example, allow to get last commit, by running git log -1 HEAD
      - for example, to notify
**** email workflow hooks
     all invoked by the git am command
***** applypatch-msg
      - takes 1 parameter
        - path of the temporary file that contains the proposed commit message
      - on non-zero exit, aborts the process
      - for example, to validate commit message
      - for example, to normalize commit message
***** pre-applypatch
      - run after the patch is applied
      - run before a commit is made
      - on non-zero exit, aborts the process
      - for example, to inspect snapshot/working tree
      - for example, to apply lint, run test
***** post-applypatch
      - run after the commit is made
      - can't stop the patching process
      - for example, to notify
**** other
***** pre-rebase
      - by git rebase
      - before you rebase anything
      - on non-zero exit, aborts the process
      - for example, to disallow rebasing any commits that have already been pushed
***** post-rewrite
      - by git commit --amend / git rebase, but not git filter-branch
      - takes 1 parameter
        - command that triggered the rewrite
      - stdin: receives a list of rewrites
      - for example, to notify
***** post-checkout
      - by git checkout
      - for example, to setup working directory
      - for example, to generate documentation
***** post-merge
      - by git merge
      - after a successful merge
      - for example, to notify
      - for example, to restore permission
      - for example, to validate presence of file external to git control
***** pre-push
      - by git push
      - after the remote refs have been updated
      - before any objects have been transferred
      - takes 2 parameters
        - name of the remote
        - location of the remote
      - stdin: list of to-be-updated refs
      - on non-zero exit, aborts the process
      - for example, to validate a set of ref updates before a push occurs
***** pre-auto-gc
      - by git gc --auto
      - git runs garbage collection as part of its normal operation
      - before the garbage collection takes place
      - on non-zero exit, aborts the process
      - for example, to notify about garbage collection running
      - for example, to block garbage collection
*** server-side
    triggered by network operations such as receiving pushed commits
    run before and after pushes to the server

    to enforce nearly any kind of policy for your project
**** pre-receive
     - run first
     - run when handling a push from a client
     - run only once, even if trying to push to multiple branches
     - stdin: list of references that are being pushed
     - on non-zero exit, aborts the process
     - for example, to be sure none of the updated references are non-fast-forwards
     - for example, to do access control for all the refs and files that will be modified
**** update
     - run once for each branch the pusher is trying to update
     - takes 3 parameters
       - the name of the reference (branch)
       - the SHA-1 that reference pointed to before the push
       - the SHA-1 the user is trying to push
     - on non-zero exit, aborts the process for the current reference
**** post-receive
     - runs after the entire process is completed
     - for example, to notify
       - mailing list
       - continuous integration server
       - ticket-tracking system
     - can’t stop the push process
     - the client doesn’t disconnect until it has completed, so be careful if
       you try to do anything that may take a long time
*** git enforced policy - server-side
**** update hook
     The update hook runs once per branch being pushed and takes three arguments:
     - the name of the reference being pushed to
     - the old revision where that branch was
     - the new revision being pushed

     You also have access to the user doing the pushing if the push is being run
     over SSH.
     If everyone connect with a single user (git) via public-key
     authentication, you may have to give that user a shell wrapper that
     determines which user is connecting based on the public key.

     script head
     #+begin_src ruby
       #!/usr/bin/env ruby

       $refname = ARGV[0]
       $oldrev = ARGV[1]
       $newrev = ARGV[2]
       $user = ENV['USER']

       puts "Enforcing Policies..."
       puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"
     #+end_src
**** enforcing a specific commit-message format
     verify that commit message contains a ref
     #+begin_src ruby
       #!/usr/bin/env ruby

       $refname = ARGV[0]
       $oldrev = ARGV[1]
       $newrev = ARGV[2]
       $user = ENV['USER']

       puts "Enforcing Policies..."
       puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"

       $regex = /\[ref: (\d+)\]/

       # enforced custom commit message format
       def check_message_format
         missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
         missed_revs.each do |rev|
           message = `git cat-file commit #{rev} | sed '1,/^$/d'`
           if !$regex.match(message)
             puts "[POLICY] Your message is not formatted correctly"
             exit 1
           end
         end
       end
       check_message_format
     #+end_src
**** enforcing a user-based acl system
     create an acl file in the repository:
     #+begin_src text
       avail|nickh,pjhyett,defunkt,tpw
       avail|usinclair,cdickens,ebronte|doc
       avail|schacon|lib
       avail|schacon|tests
     #+end_src

     update hook:
     #+begin_src ruby
       #!/usr/bin/env ruby

       $refname = ARGV[0]
       $oldrev = ARGV[1]
       $newrev = ARGV[2]
       $user = ENV['USER']

       puts "Enforcing Policies..."
       puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"

       def get_acl_access_data(acl_file)
         # read in ACL data
         acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
         access = {}
         acl_file.each do |line|
           avail, users, path = line.split('|')
           next unless avail == 'avail'
           users.split(',').each do |user|
             access[user] ||= []
             access[user] << path
           end
         end
         access
       end

       # only allows certain users to modify certain subdirectories in a project
       def check_directory_perms
         access = get_acl_access_data('acl')

         # see if anyone is trying to push something they can't
         new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
         new_commits.each do |rev|
           files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
           files_modified.each do |path|
             next if path.size == 0
             has_file_access = false
             access[$user].each do |access_path|
               if !access_path # user has access to everything
                 || (path.start_with? access_path) # access to this path
                 has_file_access = true
               end
             end
             if !has_file_access
               puts "[POLICY] You do not have access to push to #{path}"
               exit 1
             end
           end
         end
       end

       check_directory_perms
     #+end_src

*** git enforced policy - client-side
    enforce/test policy on client-side before being rejected at push time
**** commit-msg for commit message ref check
     #+begin_src ruby
       #!/usr/bin/env ruby
       message_file = ARGV[0]
       message = File.read(message_file)
       $regex = /\[ref: (\d+)\]/
       if !$regex.match(message)
         puts "[POLICY] Your message is not formatted correctly"
         exit 1
       end
     #+end_src
**** pre-commit for ACL check
     #+begin_src ruby
       #!/usr/bin/env ruby

       $user = ENV['USER']

       # [ insert acl_access_data method from above ]
       # only allows certain users to modify certain subdirectories in a project
       def check_directory_perms
         access = get_acl_access_data('.git/acl')

         files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
         files_modified.each do |path|
           next if path.size == 0
           has_file_access = false
           access[$user].each do |access_path|
             if !access_path || (path.index(access_path) == 0)
               has_file_access = true
             end
             if !has_file_access
               puts "[POLICY] You do not have access to push to #{path}"
               exit 1
             end
           end
         end
       end

       check_directory_perms
     #+end_src
*** resources
**** commit-msg
     http://git.io/validate-commit-msg
** internals
*** .git content
    - description
      used only by the GitWeb program
    - config
      project-specific configuration options
    - info/
      directory keeps a global exclude file for ignored patterns
    - hooks/
      contains your client- or server-side hook scripts
    - HEAD
      points to the branch you currently have checked out
    - index
      stores your staging area information
    - objects/
      stores all the content for your database
    - refs/
      stores pointers into commit objects in that data (branches, tags, remotes and more)
*** objects
    Git is a content-addressable filesystem.
    The core of Git is a simple key-value data store.

    "git hash-object" takes some data, stores it in your .git/objects directory
    (the object database), and gives you back the unique key that now refers to
    that data object.

    #+begin_src shell
      echo 'test content' | git hash-object -w --stdin
      d670460b4b4aece5915caf5c68d12f560a9fe3e4
    #+end_src

    it created in the objects:
    .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4

    display object content with:
    #+begin_src shell
      git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
      test content
    #+end_src

    create object from file
    #+begin_src shell
      echo 'version 1' > test.txt

      git hash-object -w test.txt
      83baae61804e65cc73a7201a7252750c76066a30
    #+end_src

    display object type with:
    #+begin_src shell
      git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4
      blob
    #+end_src
**** tree objects
     store the filename and also allows you to store a group of files together

     print more recent tree
     #+begin_src shell
       git cat-file -p master^{tree}
     #+end_src
     show a group of blob and tree

     prepare a tree object
     #+begin_src shell
       git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt
     #+end_src
     - --add to add file in the staging area
     - --cacheinfo to take reference from objects not working directory

     mode is:
     - 100644: normal file with 0644 permission
     - 100755: normal executable file
     - 120000: symbolic link

     write staging area out to a tree object
     #+begin_src shell
       git write-tree
       d8329fc1cc938780ffdd9f94e0d364e0ea74f579

       git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
       100644 blob 83baae61804e65cc73a7201a7252750c76066a30 test.txt
     #+end_src

     prepare a new tree
     #+begin_src shell
       echo 'new file' > new.txt
       git update-index --add new.txt

       git update-index --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
     #+end_src

     reload tree in staging area as subtree
     #+begin_src shell
       git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579

       git write-tree
       3c4e9cd789d88d8d89c1073707c3585e41b0e614

       git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
       040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 bak
       100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt
       100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
     #+end_src
**** commit objects
     to store information about snapshots:
     - who, when, why

     stores:
     - top-level tree
     - the parent commit
     - author information
     - committer information
     - commit message

     to create a commit based on an existing tree
     #+begin_src shell
       echo 'First commit' | git commit-tree d8329f
       8005e6d269737e8466d11fb68c1ea82987c90241
     #+end_src

     browse commit content
     #+begin_src shell
       git cat-file -p 8005e6d269737e8466d11fb68c1ea82987c90241
       ...
     #+end_src

     type is commit
     #+begin_src shell
       git cat-file -t 8005e6d269737e8466d11fb68c1ea82987c90241
       commit
     #+end_src

     commit with parent
     #+begin_src shell
       echo 'Second commit' | git commit-tree 0155eb -p 8005e6d269737e8466d11f
       50fe600211f3b914f39f37caba4ba187fde806e6

       echo 'Third commit' | git commit-tree 3c4e9c -p 50fe600211f3b914f
       19b6d38f7bb6531539a89a5cae520fcc34d0dc75
     #+end_src

     browse commit history now
     #+begin_src shell
       git log --stat 19b6d38f7bb65
     #+end_src
**** object storage
     content to store is: "what is up, doc?"
     #+begin_src ruby
       content = "what is up, doc?"
     #+end_src

     git first construct the header
     #+begin_src ruby
       header = "blob #{content.bytesize}\0"
       # => "blob 16\u0000"
     #+end_src

     git concatenates header and content and calculate SHA-1
     #+begin_src ruby
       store = header + content
       # => "blob 16\u0000what is up, doc?"

       require 'digest/sha1'

       sha1 = Digest::SHA1.hexdigest(store)
       # => "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
     #+end_src

     should obtain the same output from git command
     #+begin_src shell
       echo -n "what is up, doc?" | git hash-object --stdin
       bd9dbf5aae1a3862dd1526723246b20206e5fc37
     #+end_src

     git compress store with zlib
     #+begin_src ruby
       require 'zlib'

       zlib_content = Zlib::Deflate.deflate(store)
       # => "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"
     #+end_src

     git write compressed content to an object on disk
     #+begin_src ruby
       path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
       # => ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"

       require 'fileutils'

       FileUtils.mkdir_p(File.dirname(path))
       # => ".git/objects/bd"

       File.open(path, 'w') { |f| f.write zlib_content }
       # => 32
     #+end_src

     check final content
     #+begin_src shell
       git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37
       what is up, doc?
     #+end_src
*** references
     A file in which you could store that SHA-1 value under a simple name so you
     could use that simple name rather than the raw SHA-1 value.

     under the .git/refs directory
     #+begin_src shell
       find .git/refs
       .git/refs
       .git/refs/heads
       .git/refs/tags

       find .git/refs -type f
     #+end_src

     command is show-ref
     #+begin_src shell
       git show-ref
       git show-ref --heads
       git show-ref --tags
     #+end_src
**** branch
     to simply edit ref
     #+begin_src shell
       echo 1a410efbd13591db07496601ebc7a059dd55cfe9 > .git/refs/heads/master
     #+end_src
     but prefer to
     #+begin_src shell
       git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
     #+end_src

     a branch in git is a refs to a commit SHA-1

     to create a branch
     #+begin_src shell
       git update-ref refs/heads/test cac0ca
     #+end_src
**** HEAD
      HEAD is a reference to another reference.
      a symbolic reference.

      In some rare cases, the HEAD file may contain the SHA-1 value of a git
      object.
      When checkout:
      - a tag
      - a commit
      - a remote branch
      which puts the repository in "detached HEAD" state.

      read content of symbolic reference:
      #+begin_src shell
        cat .git/HEAD
        ref: refs/heads/master
      #+end_src

      or:
      #+begin_src shell
        git symbolic-ref HEAD
        refs/heads/master
      #+end_src

      edit HEAD with:
      #+begin_src shell
        git symbolic-ref HEAD refs/heads/test

        cat .git/HEAD
        ref: refs/heads/test
      #+end_src
**** tags
***** lightweight
       a reference that never moves.

       create a lightweight tag:
       #+begin_src shell
         git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
       #+end_src
***** annoted
       The tag object is very much like a commit object,
       it contains:
       - a tagger
       - a date
       - a message
       - a pointer
       it generally points to a commit, like a branc reference,
       but it never moves,
       it always points to the same commit, and gives it a friendlier name.

       create an annoted tag:
       #+begin_src shell
         git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'Test tag'

         cat .git/refs/tags/v1.1
         9585191f37f7b0fb9444f35a9bf50de191beadc2

         git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
         object 1a410efbd13591db07496601ebc7a059dd55cfe9
         type commit
         [...]
       #+end_src

       can tag any Git object

       for example tag gpg blob key
       #+begin_src shell
         git cat-file blob gpg-pub-maintainer
       #+end_src
**** remotes
     in the refs/remotes directory.

     for example:
     #+begin_src shell
       cat .git/refs/remotes/origin/master
       ca82a6dff817ec66f44342007202690a93763949
     #+end_src

     - are considered read-only.
     - managed as bookmarks to the last knows state for branches on remote
     - won't be referenced by symbolic reference HEAD
*** packfiles
    Occasionally Git packs up several of these objects into a single binary file
    called a "packfile" in order to save space and be more efficient.

    Git does this if you have too many loose objects around, if you run the git
    gc command manually, or if you push to a remote server.

    #+begin_src shell
      git gc
      Counting objects: 18, done.
      Delta compression using up to 8 threads.
      Compressing objects: 100% (14/14), done.
      Writing objects: 100% (18/18), done.
      Total 18 (delta 3), reused 0 (delta 0)
    #+end_src

    If you look in your objects directory, you’ll find that most of your objects
    are gone, and a new pair of files has appeared:
    #+begin_src shell
      find .git/objects -type f
      .git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
      .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
      .git/objects/info/packs
      .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
      .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack
    #+end_src

    objects considered dangling (not pointed by any commits) are not packed up
    in your new packfile.

    The packfile is a single file containing the contents of all the objects
    that were removed from your filesystem.
    When Git packs objects, it looks for files that are named and sized
    similarly, and stores just the deltas from one version of the file to the
    next.

    browse pack content:
    #+begin_src shell
      git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
      2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
      69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
      80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
      43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
      092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
      [...]
      .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok
    #+end_src

    the last version is stored intact, whereas older versions are stored as
    a delta — this is because you’re most likely to need faster access to the
    most recent version of the file.
*** refspec
    The format of the refspec is, first, an optional +, followed by <src>:<dst>,
    where <src> is the pattern for references on the remote side and <dst> is
    where those references will be tracked locally. The + tells Git to update
    the reference even if it isn’t a fast-forward.

    example in .git/config
    #+begin_src conf
      fetch = +refs/heads/*:refs/remotes/origin/*

      fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
    #+end_src
**** fetch
     with the first previous line, following references are equivalent:
     #+begin_src shell
       git log origin/master
       git log remotes/origin/master
       git log refs/remotes/origin/master
     #+end_src
     all are expanded to refs/remotes/origin/master

     to fetch master only, in .git/config
     #+begin_src conf
       fetch = +refs/heads/master:refs/remotes/origin/master
     #+end_src

     fetch manually with specific refspec
     #+begin_src shell
       git fetch origin master:refs/remotes/origin/mymaster

       git fetch origin master:refs/remotes/origin/mymaster \
                        topic:refs/remotes/origin/topic
     #+end_src

     partial glob is also supported
     #+begin_src conf
       fetch = +refs/heads/qa*:refs/remotes/origin/qa*
     #+end_src

     or use namespace
     #+begin_src conf
       fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*
     #+end_src
**** push
     push manually to a specific refspec
     #+begin_src shell
       git push origin master:refs/heads/qa/master
     #+end_src

     push automatically to a specific refspec (.git/config)
     #+begin_src conf
       fetch = +refs/heads/*:refs/remotes/origin/*
       push = refs/heads/master:refs/heads/qa/master
     #+end_src
     this will cause a git push origin to push the local master branch to the
     remote qa/master branch by default
**** delete
     delete reference on remote with:
     #+begin_src shell
       git push origin :topic
     #+end_src
     Because the refspec is <src>:<dst>, by leaving off the <src> part, this
     basically says to make the topic branch on the remote nothing, which
     deletes it.

     or use the newer syntax:
     #+begin_src shell
       git push origin --delete topic
     #+end_src
*** transfer protocols
**** dumb protocol
**** smart protocol
*** maintenance
    "gc" tands for garbage collect
    - it gathers up all the loose objects and places them in packfiles
    - it consolidates packfiles into one big packfile
    - it removes objects that aren’t reachable from any commit and are a few months old

    #+begin_src shell
      git gc --auto
    #+end_src

    - it packs up references into a single file
    #+begin_src shell
      find .git/refs -type f
      # to
      cat .git/packed-refs
    #+end_src
*** data recovery
**** reflog
     use the reflog
     located in .git/logs

     #+begin_src shell
       git reflog
       # or
       git log -g
     #+end_src
**** fsck
     check database for integrity
     #+begin_src shell
       git fsck --full
     #+end_src

     with --full, it shows all objects that aren't pointed to by another object

     dangling commit are lost heads to recover
**** COMMENT removing objects
     to remove old large file that are present in history

     count objects
     #+begin_src shell
       git count-objects -v
     #+end_src

     use verify-pack to sort object by size
     #+begin_src shell
       git verify-pack -v .git/objects/pack/pack-29…69.idx \
           | sort -k 3 -n \
           | tail -3
     #+end_src

     verify association between blob and file path
     #+begin_src shell
       git rev-list --objects --all | grep <blob id>
     #+end_src

     check all commit associated to the file path
     #+begin_src shell
       git log --oneline --branches -- <file_path_associted_to_blob_id>
     #+end_src

     filter-branch by removing file in index
     #+begin_src shell
       git filter-branch --index-filter \
       'git rm --ignore-unmatch --cached git.tgz' -- <first_commit_found>^..
     #+end_src

     clear reference added by filter-branch
     #+begin_src shell
       rm -Rf .git/refs/original
     #+end_src

     clear reflog
     #+begin_src shell
       rm -Rf .git/logs/
     #+end_src

     repack and check
     #+begin_src shell
       git gc
       git count-objects -v
     #+end_src

     clean dangling with
     #+begin_src shell
       git prune --expire now
       git count-objects -v
     #+end_src
*** environment variables
**** global behavior
***** HOME
      system-wide configuration, for portable git install
      to resolve global configuration
***** PREFIX
      system-wide configuration
      to resolve $PREFIX/etc/gitconfig
***** GIT_EXEC_PATH
      where Git looks for its sub-programs (like git-commit, git-diff, and others)
      check the current setting by running git --exec-path
***** GIT_CONFIG_NOSYSTEM
      if set, disables the use of the system-wide configuration file
***** GIT_PAGER
      controls the program used to display multi-page output on the command line
      if unset, fallback to PAGER variable
***** GIT_EDITOR
      the editor Git will launch when the user needs to edit some text
      if unset, fallback to EDITOR variable
**** repository locations
***** GIT_DIR
      the location of the .git folder.

      if unset, git walks up the directory tree until it gets to ~ or /, looking
      for a .git directory at every step.
***** GIT_CEILING_DIRECTORIES
      controls the behavior of searching for a .git directory.
      to have Git stop trying earlier than it might otherwise, especially if Git
      is invoked when building your shell prompt.
***** GIT_WORK_TREE
      the location of the root of the working directory for a non-bare repository.
      if --git-dir or GIT_DIR is specified but none of --work-tree,
      GIT_WORK_TREE or core.worktree is specified, the current working directory
      is regarded as the top level of your working tree.
***** GIT_INDEX_FILE
      the path to the index file (non-bare repositories only).
***** GIT_OBJECT_DIRECTORY
      can be used to specify the location of the directory that usually resides at .git/objects.
***** GIT_ALTERNATE_OBJECT_DIRECTORIES
      is a colon-separated list (formatted like /dir/one:/dir/two:…)
      tells Git where to check for objects if they aren't in GIT_OBJECT_DIRECTORY.
**** pathspecs
***** GIT_GLOB_PATHSPECS  / GIT_NOGLOB_PATHSPECS
      control the default behavior of wildcards in pathspecs.
      if GIT_GLOB_PATHSPECS is set to 1, wildcard characters act as wildcards (which is thedefault)
      if GIT_NOGLOB_PATHSPECS is set to 1, wildcard characters only match themselves
      can be overrided in individual cases by starting the pathspec with :(glob) or :(literal), as in :(glob)\*.c
***** GIT_LITERAL_PATHSPECS
      disables both of the above behaviors; no wildcard characters will work,
      and the override prefixes are disabled as well.
***** GIT_ICASE_PATHSPECS
      sets all pathspecs to work in a case-insensitive manner.
**** committing
***** GIT_AUTHOR_NAME
      the human-readable name in the “author” field
***** GIT_AUTHOR_EMAIL
      the email for the “author” field
***** GIT_AUTHOR_DATE
      the timestamp used for the “author” field
***** GIT_COMMITTER_NAME
      the human name for the “committer” field
***** GIT_COMMITTER_EMAIL
      the email address for the “committer” field
***** GIT_COMMITTER_DATE
      the timestamp in the “committer” field
***** EMAIL
      the fallback email address in case the user.email configuration value isn’t set.
      ff isn't set, Git falls back to the system user and host names.
**** networking
     git uses the curl library to do network operations over HTTP,
     so GIT_CURL_VERBOSE tells Git to emit all the messages generated by that library.
     This is similar to doing curl -v on the command line.
***** GIT_SSL_NO_VERIFY
      to not verify SSL certificates.
***** GIT_HTTP_LOW_SPEED_LIMIT / GIT_HTTP_LOW_SPEED_TIME
      if the data rate of an HTTP operation is lower than
      GIT_HTTP_LOW_SPEED_LIMIT bytes per second for longer than
      GIT_HTTP_LOW_SPEED_TIME seconds, Git will abort that operation. These
      values override the http.lowSpeedLimit and http.lowSpeedTime configuration
      values.
***** GIT_HTTP_USER_AGENT
      sets the user-agent string used by Git when communicating over HTTP.
      The default is a value like git/2.0.0.
**** diffing and merging
***** GIT_DIFF_OPTS
      is a bit of a misnomer.
      The only valid values are -u<n> or --unified=<n>, which controls the number of context lines shown in a git diff command.
***** GIT_EXTERNAL_DIFF
      is used as an override for the diff.external configuration value.
      If it’s set, Git will invoke this program when git diff is invoked.
***** GIT_DIFF_PATH_COUNTER / GIT_DIFF_PATH_TOTAL
      are useful from inside the program specified by GIT_EXTERNAL_DIFF or diff.external.
      The former represents which file in a series is being diffed (starting with 1),
      and the latter is the total number of files in the batch.
***** GIT_MERGE_VERBOSITY
      controls the output for the recursive merge strategy.
      The allowed values are as follows:
      - 0 outputs nothing, except possibly a single error message.
      - 1 shows only conflicts.
      - 2 also shows file changes.
      - 3 shows when files are skipped because they haven’t changed.
      - 4 shows all paths as they are processed.
      - 5 and above show detailed debugging information.
      The default value is 2.
**** debugging
     to turn on git traces
     values are:
     - “true”, “1”, or “2” – the trace category is written to stderr.
     - an absolute path starting with / – the trace output will be written to that file.
***** GIT_TRACE
      controls general traces, which don’t fit into any specific category.
      This includes the expansion of aliases, and delegation to other sub-programs.
***** GIT_TRACE_PACK_ACCESS
      controls tracing of packfile access.
      The first field is the packfile being accessed, the second is the offset within that file.
***** GIT_TRACE_PACKET
      enables packet-level tracing for network operations.
***** GIT_TRACE_PERFORMANCE
      controls logging of performance data.
      The output shows how long each particular git invocation takes.
***** GIT_TRACE_SETUP
      shows information about what Git is discovering about the repository and
      environment it’s interacting with.
**** miscellaneous
***** GIT_SSH
      if specified, is a program that is invoked instead of ssh when Git tries
      to connect to an SSH host.
      it is invoked like $GIT_SSH [username@]host [-p <port>] <command>.
      Note that this isn't the easiest way to customize how ssh is invoked;
      it won’t support extra command-line parameters, so you’d have to write a wrapper script and set GIT_SSH to point to it.
      it’s probably easier just to use the ~/.ssh/config file for that.
***** GIT_ASKPASS
      is an override for the core.askpass configuration value.
      This is the program invoked whenever Git needs to ask the user for
      credentials, which can expect a text prompt as a command-line argument,
      and should return the answer on stdout (see Credential Storage for more on
      this subsystem).
***** GIT_NAMESPACE
      controls access to namespaced refs, and is equivalent to the --namespace flag.
      This is mostly useful on the server side, where you may want to store
      multiple forks of a single repository in one repository, only keeping the
      refs separate.
***** GIT_FLUSH
      can be used to force Git to use non-buffered I/O when writing incrementally to stdout.
      - a value of 1 causes Git to flush more often,
      - a value of 0 causes all output to be buffered.
      The default value (if this variable is not set) is to choose an
      appropriate buffering scheme depending on the activity and the output
      mode.
***** GIT_REFLOG_ACTION
      lets you specify the descriptive text written to the reflog.
** good commit
*** atomic
    - self-contained:
      sementically related changes should not be splitted across commits
    - coherent:
      all change in 1 commit should be semantically related

    -> 1 change = 1 commit

    commit should be kept relatively small,
    do not try to do too much in 1 commit
*** consistent
    - no compilation errors
      a commit should not introduce compilation errors
    - no broken tests
      a commit should not break any existing tests nor add failing ones

    -> should not introduction quality regressions

    each commit should be apply-able/build-able individually
*** incremental
    - ordered:
      commits should be ordered deliberately (not arbitrary)
    - explanatory:
      the order should be a trail of the programmer's thought process

    -> should reflect the development flow
*** documented
    - a short summary:
      a commit message should include a short one-sentence summary
    - detailed description:
      a longer description can be added if more details are necessary

    -> meaning and role of the change, and the reason behind it
*** message
   summary: 50 chars max
   longer description: 72 chars max per line
** Branching patterns
*** base patterns (integration + path to production)
**** source branching
     Create a copy and record all changes to that copy.

     - codeline
     - branch
     - clone
     - fork
     =>  illusion of frozen time
         the only ones changing the system
**** mainline
     A single, shared, branch that acts as the current state of the product.
**** healthy branch
     On each commit, perform automated checks, usually building and running
     tests, to ensure there are no defects on the branch
*** integration patterns
    Thinking about branching strategies is really all about deciding how and
    when we integrate.
**** mainline integration
     Developers integrate their work by pulling from mainline, merging, and - if
     healthy - pushing back into mainline.
**** feature branching
     Put all work for a feature on its own branch, integrate into mainline when
     the feature is complete.
**** integration frequency
     - integration complexity, risk
     - integration fear
***** low-frequency
***** high-frequency
**** continuous integration
     Developers do mainline integration as soon as they have a healthy commit
     they can share, usually less than a day's work.
**** feature branching vs. continuous integration
**** pre-integration review
     Every commit to mainline is peer-reviewed before the commit is accepted.

     "Many teams that use pre-integration reviews don't do them quickly enough.
      The valuable feedback that they can offer then comes too late to be useful.
      At that point there's an awkward choice between a lot of rework, or
      accepting something that may work, but undermines the quality of the
      code-base."

     Refinement Code Review ?
**** integration friction
**** modularity
*** the path from mainline to production release
**** release branch
     A branch that only accepts commits accepted to stabilize a version of the
     product ready for release.
**** maturity branch
     A branch whose head marks the latest version of a level of maturity of the
     code base.
**** long lived release branch
     a release branch pattern, combined with a maturity branch for a release
     candidate

     = release branch + maturity branch
**** environment branch
     Configure a product to run in a new environment by applying a source code
     commit.
**** hotfix branch
     A branch to capture work to fix an urgent production defect.
**** release train
     Release on a set interval of time, like trains departing on a regular
     schedule. Developers choose which train to catch when they have completed
     their feature.
**** release-ready mainline
     Keep mainline sufficiently healthy that the head of mainline can always be
     put directly into production.
**** experimental branch
     Collects together experimental work on a code base, that's not expected to
     be merged directly into the product.
**** future branch
     A single branch used for changes that are too invasive to be handled with
     other approaches.
**** collaboration branch
     A branch created for a developer to share work with other members of the
     team without formal integration.
**** team integration branch
     Allow a sub-team to integrate with each other, before integrating with
     mainline.
*** branching policies
**** git-flow
**** github flow
**** trunk-based development
*** wording
**** branch
**** codeline
**** textual conflict
**** semantic conflict
     https://martinfowler.com/bliki/SemanticConflict.html
**** pull requests = feature branching + pre-integration review
**** continuous integration
**** integration fear
*** branching strategy
**** Ship / Show / Ask
     from: https://martinfowler.com/articles/ship-show-ask.html
***** ship
      like Continuous Integration
      when:
      - I added a feature using an established pattern
      - I fixed an unremarkable bug
      - I updated documentation
      - I improved my code based on your feedback
***** show
      open a Pull Request, then you merge it without waiting for anyone
      code review after merge

      when:
      - I would love your feedback on how this code could be better
      - Look at this new approach or pattern I used
      - I refactored X so now it looks like this
      - What an interesting bug! Look how I fixed it
***** ask
      open a Pull Request, and we wait for feedback before merging
      discussion & feedback before merge

      when:
      - Will this work?
      - How do we feel about this new approach?
      - I need help to make this better please
      - I'm done for today, will merge tomorrow
***** the rules
      - Code review, or “Approval”, should not be a requirement for a Pull
        Request to be merged.
      - People get to merge their own Pull Requests. This way they’re in control
        of whether their change is a “Show” or an “Ask”, and they can decide
        when it goes live.
      - We’ve got to use all the great Continuous Integration and Continuous
        Delivery techniques that help keep the mainline releasable. Take Feature
        Toggles as one example.
      - Our branches should not live long, and we should rebase them on the
        mainline often.
** github
*** markdown
**** emoji
    https://www.webfx.com/tools/emoji-cheat-sheet/
*** special files
**** README
     could be README, README.md, README.asciidoc, ...

     generally contains
     - What the project is for
     - How to configure and install it
     - An example of how to use it or get it running
     - The license that the project is offered under
     - How to contribute to it
**** CONTRIBUTING
     provides guidelines for contributing
*** hook
**** webhooks documentation
     https://developer.github.com/webhooks/
**** example service
     #+begin_src ruby
       require 'sinatra'
       require 'json'
       require 'mail'

       post '/payload' do
         push = JSON.parse(request.body.read) # parse the JSON

         # gather the data we're looking for
         pusher = push["pusher"]["name"]
         branch = push["ref"]

         # get a list of all the files touched
         files = push["commits"].map do |commit|
           commit['added'] + commit['modified'] + commit['removed']
         end
         files = files.flatten.uniq

         # check for our criteria
         if pusher == 'schacon' &&
            branch == 'ref/heads/special-branch' &&
            files.include?('special-file.txt')

           Mail.deliver do
             from     'tchacon@example.com'
             to       'tchacon@example.com'
             subject  'Scott Changed the File'
             body     'ALARM'
           end
         end
       end
     #+end_src
**** API
***** example: check status of PR
      #+begin_src ruby
        require 'httparty'
        require 'sinatra'
        require 'json'

        post '/payload' do
          push = JSON.parse(request.body.read) # parse the JSON
          repo_name = push['repository']['full_name']
          # look through each commit message
          push["commits"].each do |commit|
            # look for a Signed-off-by string
            if /Signed-off-by/.match commit['message']
              state = 'success'
              description = 'Successfully signed off!'
            else
              state = 'failure'
              description = 'No signoff found.'
            end
            # post status to GitHub
            sha = commit["id"]
            status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"
            status = {
              "state"
              => state,
              "description" => description,
              "target_url" => "http://example.com/how-to-signoff",
              "context"
              => "validate/signoff"
            }
            HTTParty.post(status_url,
                          :body => status.to_json,
                          :headers => {
                            'Content-Type' => 'application/json',
                            'User-Agent'
                            => 'tonychacon/signoff',
                            'Authorization' => "token #{ENV['TOKEN']}" }
                         )
          end
        end
      #+end_src
***** API client: octokit
      https://github.com/octokit

** arround
*** p4merge as a diff & merge tool
    - install the script
    - create a wrapper script: /usr/local/bin/extMerge
      #+begin_src shell
        #!/bin/sh
        /Applications/p4merge.app/Contents/MacOS/p4merge $*
      #+end_src
    - by default, Git passes the following arguments to the diff program:
      #+begin_src shell
        path old-file old-hex old-mode new-file new-hex new-mode
      #+end_src
    - generic extDiff wrapper: /usr/local/bin/extDiff
      #+begin_src shell
        #!/bin/sh
        [ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"
      #+end_src
    - configure your custom merge resolution and diff tools
      #+begin_src shell
        git config --global merge.tool extMerge
        git config --global mergetool.extMerge.cmd 'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'
        git config --global mergetool.extMerge.trustExitCode false
        git config --global diff.external extDiff
      #+end_src
** fun
*** commit message
    http://whatthecommit.com/
** questions/answers
*** list diff of commits between 2 branches with patch equivalent
    #+begin_src shell
      git log --cherry-mark --left-right --no-merges master...feature
    #+end_src
    to consider only 1 side, use
    --left-only / --right-only
*** list diff of commits between 2 branches without patch equivalent
    #+begin_src shell
      git log --cherry-pick --left-right --no-merges master...feature
    #+end_src
    to consider only 1 side, use
    --left-only / --right-only
*** list present in one feature branch and not in master
    #+begin_src shell
      git log --cherry-pick --right-only --no-merges master...feature
    #+end_src
    or
    #+begin_src shell
      git log --cherry-mark --right-only --no-merges master...feature
    #+end_src

    2nd can be shortened to
    #+begin_src shell
      git log --cherry master...feature
    #+end_src
*** find all merges between 2 branches
    list merge commits reachable from master but not from feature branch
    #+begin_src shell
      git log --merges feature..master
    #+end_src
*** find latest merge between 2 branches
    #+begin_src shell
      git log --merges --ancestry-path feature..master
    #+end_src
*** find commits where a file is changed
    #+begin_src shell
      git log --follow calculator.c
    #+end_src
*** find commits that have added/removed on specific string
    -S : display added XOR removed (exclude modified)
    -G : display added AND/OR removed (both)

    raw string
    #+begin_src shell
      git log -S<string>
    #+end_src

    regular expression
    #+begin_src shell
      git log -S".*is.*" --pickaxe-regex
    #+end_src

    regular expression
    #+begin_src shell
      git log -G".*is.*"
    #+end_src
*** find commits where a function is modified
    #+begin_src shell
      git log -L:substract:calculator.c
    #+end_src
    find commits, where substract function is modified in file calculator.c

    parser is configured in .gitattributes
    #+begin_src conf
      *.java  diff=java
      *.ruby  diff=ruby
    #+end_src

    supported languages:
    https://git-scm.com/docs/gitattributes#_defining_a_custom_hunk_header
*** find commits by (patch) author
    #+begin_src shell
      git lg --author="thomas"
    #+end_src
*** find commits by committer
    #+begin_src shell
      git lg --committer="thomas"
    #+end_src
*** find commits by time frame
    #+begin_src shell
      git lg --since="1 week" --until="2 days ago"
    #+end_src

    date format is managed by approxidate
*** top 10 Author
    #+begin_src shell
      git shortlog -s -n | head -10
    #+end_src
*** list dangling commits
    #+begin_src shell
      git fsck --dangling --no-reflogs --no-progress
    #+end_src
*** list unreachable commits
    #+begin_src shell
      git fsck --unreachable --no-reflogs --no-progress
    #+end_src
